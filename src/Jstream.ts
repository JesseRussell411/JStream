//                   ,▄▄██████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████▓▄╖
//                ,▄███████▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀███████▄
//              ╓██████▄▒▒▒▒▒▄▄▄▄▒▒▒▒▒▄▄▄▄▒▒▒░▒▄▄▄▄▒▒▒▒▒▄▄▄▄▄▒▒▒▒▄▄▄▄▄▒▒▒▒▄▄▄▄▄▒▒▒▒▄▄▄▄▄▒▒▒▒▄▄▄▄▄░▒▒▒▒▄▄▄▄▒▒▒▒▒▄▄▄▄▒▒▒▒▒▄▄▄▄▒▒▒▒▒▄▄▄▄▒▒▒▒▒▄▄▄▄▒▒▒▒▒▄▄▄▄▒▒▒▒▒▄▄▄▄▒▒▒▒▒▄▄▄▄▒▒▒▒▒▄▄▄▄▄▒▀████▄
//             ▄███▓▒▒▀▀███▓▄▄░▀▀███▓▄▄▒░▀███▓▄▄▒░▀████▄▄▒░▀████▄▄▒░▀▀███▄▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒▒▀▀███▓▄▒▒▀▀███▓▄▒░▀▀███▓▄▄▒▀▀███▓▄▄▒░▀████▄▄▒░▀████▄▄▒░▀▀███▓████▄
//            ████░▀███▓▄▄▒▒▀████▄▄▒▒▀▀███▄▄▒▒▀▀███▄▄▒░▀▀███▄▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒▒▀▀███▓▄▒▒▀▀███▓▄▄▒▀▀███▓▄▄▒▒▀███▓▄▄▒▒▀████▄▄▒▒▀▀███▄▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▒▀███▌
//           ▐███░▒▒▒▒░░▀▀▀▀╨▒▒░░▀▀▀▀▀▒▒░░▀▀▀▀▀▒▒░░▀▀▀▀▀▒▒▒░▀▀▀▀▀▒▒▒░▀▀▀▀▀▒▒▒░▀▀▀▀▀▒▒▒░▀▀▀▀▀▒▒▒░▀▀▀▀▀▒▒▒░▒▀▀▀▀╣▒▒░▒▀▀▀▀╨▒▒░▒▀▀▀▀╬▒▒░░▀▀▀▀╨▒▒░░▀▀▀▀╨▒▒░░▀▀▀▀▀▒░░░▀▀▀▀▀▒▒░░▀▀▀▀▀▒▒▒░▀▀▀▀▀▒▒▐███U
//           ███▌▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▄▄░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒███▌
//           ███▌▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▓███████▄▒▒▒▒▒▒▒▄▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓██▓
//           ███▌▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▄██████░▒▒░░░▒▒░███▀░▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▄▄▄▄▄▄▒▒▒▒▒▒▄▄▄▄▄▒▒▒░▒▒▒▒▄▄▄▄▄░▒▒▒▒▒▄▄▄▄▄▒▒▒▒▒▒▒▒▄▄▄▄▄▄▄▄▄▄▄▒▒▒▒▒▒▒▒▒▒▒▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▒▒▒▒▒▒▒▄▄▄▄▄▄▄▄▄▄▄▄▄▒▒▒▒▒▒▒▒▒░▒▓██▓
//           ███▌▒▒▒▒▒░▒▒▒▒▒▒▒▒███████▒▒▒▒▒▒▒░▒███▄▒▒▒▒▓▒▒▒▒▒▒▒▒▒▒░▒▒██████▒▒▒▒▒▐█████▒▒░▒▒░▒▓██████▒▒▒▒░█████▌▒▒▒▒▒▒▐█████████████▓░▒▒▒▒▒▒░███████████████▒▒▒▒▒░▐███████████████░▒▒▒▒▒▒░▒▓██▓
//           ███▌▒▒▒▒▒▒▒▒▒▒▒██████▓▀████▄▒░░▒▒▄█████▄██▓░▒▒▒▒▒▒▒▒▒░▒▒██████▒▒▒▒▒▐█████▒▒░▒▒░▒▓███████▓▒▒▒█████▌▒▒▒▒▒▒▐█████▀▀▀▀██████▒▒▒▒▒▒░██████░░░░░░░░░▒▒▒▒▒░▐█████▌▒░░▒█████▌░▒▒▒▒▒░▒▓██▓
//           ███▌▒▒▒▒▒░░▒▒▒▒░▀███▒▒▒▒░▀███▄▒▓██████▀▀▀░▒▒▒▒▒▒▒▒▒▒▒░▒▒██████▒▒▒▒▒▐█████▒▒░▒▒░▒▓█████████▒░█████▌▒▒▒▒▒▒▐█████░░░▒░█████▓▒▒▒▒▒░██████▄▓▓▓▓▓▓▄▒▒▒▒▒▒░▐█████▌▄▄▄▄█████▌▒▒▒▒▒▒░▒▓██▓
//           ███▌▒▒▒▒▒▒▒▒▒▒▒▒▒░░░▒▒▒▒░▒░▀███████▀░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒██████▒▒░▒▒▐█████▒▒░▒▒░▒▓████▓█████▌█████▌▒▒▒▒▒▒▐█████▒▒░▒▒██████▒░▒▒▒░██████████████▒░▒▒▒▒░▐█████████████▀▒▒▒▒▒▒▒▒░▒▓██▓
//           ███▌▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▒██████▓░▒▒▒▒░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓█████▒▒▒▒▒▐█████▒▒▒▒▒░▒▓████▌▒▀█████████▌▒▒▒▒▒▒▐█████▒▒▒▒▒█████▓▒▒▒▒▒░██████▒░░░░░░░▒▒▒▒▒▒░▐█████▌▀██████▌▒▒▒▒▒▒▒▒░▒▓██▓
//           ███▌▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▄▄▄██████▀███▓▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▐██████▄▄▄▄██████▒░▒▒▒░▒▓████▌▒▒░████████▌▒▒▒▒▒▒▐█████▄▄▄▄██████▒▒▒▒▒▒░██████▄▄▄▄▄▄▄▄▄░▒▒▒▒░▐█████▌▒▒▀██████░▒▒▒▒▒▒░▒▓██▓
//           ███▌▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒╫█████████░▒▒▒░████▄▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒█████████████▀░▒▒▒▒▒▒░▓████▓▒▒░▒▀██████▌▒▒▒▒▒▒▐█████████████▀░▒▒▒▒▒▒▒███████████████▒▒▒▒▒▒▐█████▌▒▒▒▒██████░▒▒▒▒▒░▒▓██▓
//           ███▌▒▒▒▒▒▒▒▒▒▒▒▒░▒▒█▀░▒░▀██▓▒▒▒▒▒▒▒░▀█▀▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▀▀▀▀▀▀▀▀▀░▒▒▒▒▒▒▒▒▒▒▒▀▀▀▀▀▒░░▒▒░▀▀▀▀▀▒▒▒▒▒▒▒░▀▀▀▀▀▀▀▀▀▀▀░▒▒▒▒▒▒▒▒▒▒▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▒▒▒▒▒▒░▀▀▀▀▀▒▒▒▒▒░▀▀▀▀▀▀▒▒▒▒▒▒▒▓██▓
//           ███▌▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▓██▒▒▒▒▒▒▒▒▒░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▓██▓
//           ███▌▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒╨▀▀▒░▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒░▒▓██▓
//           ███▌▒░▒▒▒▒▒▄▄▓▓▓▓▄▒▒▒▒░▒▒▄▄▓▓▓▓▄▒▒░▒▒▒▄▄▄▄▒▒▒▒▄▄▄▄▒▒▒▒▄▓▓▓▓▓▄▒▒▒▄▄▓▓▄▄▄▄▄▄▄▄▒▒▄▄▄▄▄▓▓▄▄▄▒▒▒▒▄▓▄▒▒▒▒▒▄▄▄▄▒░░▒▒▄▄▓▓▓▄▄▒▒▒╫▄▄▄▄▄▄▄▄▄▄▄▒▒▄▄▄▓░░░▒▒▒▄▓▓▓▓▄▄▒▒▒▒▒▄▄▓▄░▒▒▒╫▄▓▓▒▒▒▒░▒▓██▓
//           ███▌░░▒▒▒▓██████████▒▒▒▓██████████▄▒▒▓████▓▒▒▒████▒▒▓███▀▀████▌▒████████████▌▒███████████▌▒▐███▌▒▒▒▒████▒▒▒██████████▓▒▓███████████▌▒████▒▒▒▄██████████▓▒▒▒█████▒▒▒▓███▒▒▒▒░▒▓██▓
//           ███▌▒░▒▒╫███▓░▒▒░▀▀▀░▒▓███▌▒▒▒░████▒▒▓██████▄▒████▒▒█████▓▓▓▒▒░▒▒▒▒▒████▒▒▒▒▒▒████▒▒▒▓███▌▒▐███▌▒▒▒▒████▒▒████▒▒▒▒▒▀▀░▒▒▒▒▒▓███▌▒▒░▒░████▒▒▐████░▒▒░▓███▓▒▒██████▓▒▓███░▒▒▒░▒▓██▓
//           ███▌▒░░▒████▌▒▒▒▒▒▒▒▒▒████▒▒▒▒▒▓███▌▒▓███▀████████▒▒░▀▀███████▓▒▒░▒░████▒▒▒▒▒▒██████████▒▒▒▐███▌░░▒▒████▒▒████▒▒░▒▒▒▒▒▒▒▒▒▒▓███▌▒▒░▒░████▒▒╫███▌▒▒▒▒▐████▒▒███▓████████░▒▒▒░▒▓██▓
//           ███▌▒▒▒▒▐████▒▒▒▄███▌▒▓███▓▒▒▒▄████░▒▓███▒░▓██████▒╫███▌▒▒░████▒▒▒▒░████▒▒▒▒▒▒████▒░████▓▒▒▐████▒▒▒▓███▓▒░████▌▒▒▒▓███▒▒▒▒▒▓███▌▒▒░▒░████▒▒▒████▄▒▒▒████▌▒▒███▓▒▀██████░▒▒▒░▒▓██▓
//           ███▌▒▒▒▒▒▒█████████▀▒▒▒▀██████████░▒▒▓███▒▒▒▒█████▒▒▀█████████▀▒▒▒▒▒████▒▒▒▒▒▒████▒▒░█████▒▒▀█████████▓░▒▒▒▀█████████▀▒▒▒▒▒▓███▌▒▒░▒▒████▒▒▒░██████████▀▒▒▒███▓▒▒░█████▒▒▒▒▒▒▓██▓
//           ███▌▒░▒▒▒▒▒░░▀▀▀░░░▒▒▒▒▒░░░▀▀▀▀░▒▒▒▒▒░░░░░▒▒▒░░░░░▒▒▒░░░▀▀▀░░▒▒▒▒▒▒▒░░░░░▒▒▒▒▒░░░░▒▒▒▒░░░░░▒▒▒░░▀▀▀▀▒░▒▒▒▒▒▒▒░░▀▀▀░░▒▒▒▒░░▒░░░░░▒▒▒░░░░░░░▒▒▒▒░░▀▀▀▀░░▒▒▒▒░░░░░▒▒▒▒░░░░▒▒▒▒▒▒███▌
//           ▓███▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░▒▒███▌
//            ███▓▒░▀▀███▓▄▒░▀▀███▓▄▒▒▀▀███▓▄▒▒▀▀███▓▄▄▒▒▀███▓▄▄▒▒▀███▓▄▄▒░▀████▄▄▒▒▀▀███▄▄▒░▀▀███▓▄▒▒▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒▒▀▀███▓▄▒▒▀▀███▓▄▒▒▀▀███▓▄▄▒▒▀███▓▄▄▒▒▒███▓
//             ████▒█▓▄▒▒▀▀███▓▄▄▒▒▀████▄▄▒▒▀████▄▄▒▒▀████▄▄▒▒▀▀███▄▄▒▒▀▀███▄▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒▒▀▀███▓▄▄▒▀▀███▓▄▄▒▀▀████▄▄▒▒▀████▄▄▒▒▀████▄▄▒░▀▀▓▄███▀
//              ▀████▓▀███▓▄▄▒░▀███▓▄▄▒░▀▀██▓▄▄▒░▀▀███▄▄▒░▀▀███▄▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒░▀▀███▓▄▒░░▀███▓▄▒▒░▀███▓▄▄░░▀███▓▄▄▒░▀▀██▓▄▄▒░▀▀███▄▄▒░▀▀██▓▄████╜
//                ▀██████▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▓██████╙
//                   ▀▀█████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████████▀"

import AsyncJstream from "./AsyncJstream";
import {
    asStandardCollection,
    groupBy,
    memoizeIterable,
    nonIteratedCountOrUndefined,
    toMap,
} from "./privateUtils/data";
import {
    requireGreaterThanZero,
    requireInteger,
    requireNonZero,
} from "./privateUtils/errorGuards";
import { identity } from "./privateUtils/functional";
import { getOwnEntries } from "./privateUtils/objects";
import { mkString } from "./privateUtils/strings";
import { isArray, isStandardCollection } from "./privateUtils/typeGuards";
import {
    AsReadonly,
    EntryLikeKey,
    EntryLikeValue,
    ReadonlyStandardCollection,
    StandardCollection,
} from "./types/collections";
import { Comparator, Order } from "./types/sorting";
import { BreakSignal } from "./types/symbols";
import {
    AsMap,
    AsMapWithKey,
    AsMapWithValue,
    General,
    ToObject,
    ToObjectWithKey,
    ToObjectWithValue,
} from "./types/utility";
import { multiCompare, reverseOrder } from "./utils/sorting";
import { breakSignal } from "./utils/symbols";

export type JstreamProperties<_> = Readonly<
    Partial<{
        /** Each call to the source getter produces a new copy of the source. */
        freshSource: boolean;
    }>
>;

export default class Jstream<T> implements Iterable<T> {
    private readonly getSource: () => Iterable<T>;
    private readonly properties: JstreamProperties<T>;

    public constructor(
        getSource: () => Iterable<T>,
        properties: JstreamProperties<T> = {}
    ) {
        this.getSource = getSource;
        this.properties = properties;
    }

    public [Symbol.iterator]() {
        return this.getSource()[Symbol.iterator]();
    }

    public static from<T>(
        source: Iterable<T> | (() => Iterable<T>)
    ): Jstream<T> {
        if (source instanceof Function) {
            return new Jstream(source);
        } else if (source instanceof Jstream) {
            return source;
        } else {
            return new Jstream(() => source);
        }
    }

    public static of<T>(...items: T[]): Jstream<T> {
        return new Jstream(() => items);
    }

    public static empty<T>(): Jstream<T> {
        return Jstream.of<T>();
    }

    public static fromObject<K extends keyof any, V>(
        object: Record<K, V>
    ): Jstream<[K & (string | symbol), V]> {
        return new Jstream(() => getOwnEntries(object));
    }

    public forEach(
        action: (item: T, index: number) => void | BreakSignal
    ): void {
        let i = 0;
        for (const item of this) {
            const signal = action(item, i);
            if (signal === breakSignal) break;
            i++;
        }
    }

    public map<R>(mapping: (item: T, index: number) => R): Jstream<R> {
        const self = this;

        return new Jstream(function* () {
            let i = 0;
            for (const item of self) {
                yield mapping(item, i);
                i++;
            }
        });
    }

    public filter<R extends T = T>(
        predicate: (item: T, index: number) => boolean
    ): Jstream<R> {
        const self = this;

        return new Jstream(function* () {
            let i = 0;
            for (const item of self) {
                if (predicate(item, i)) yield item as R;
                i++;
            }
        });
    }

    public append<O>(item: O): Jstream<T | O> {
        const self = this;
        return new Jstream(function* () {
            yield* self;
            yield item;
        });
    }

    public prepend<O>(item: O): Jstream<O | T> {
        const self = this;
        return new Jstream(function* () {
            yield item;
            yield* self;
        });
    }

    public concat<O>(items: Iterable<O>): Jstream<T | O> {
        const self = this;
        return new Jstream(function* () {
            yield* self;
            yield* items;
        });
    }

    public preConcat<O>(items: Iterable<O>): Jstream<O | T> {
        const self = this;
        return new Jstream(function* () {
            yield* items;
            yield* self;
        });
    }

    public sortBy(order: Order<T>): SortedJstream<T> {
        return new SortedJstream(this.getSource, [order], this.properties);
    }

    public sortByDescending(order: Order<T>): SortedJstream<T> {
        return new SortedJstream(
            this.getSource,
            [reverseOrder(order)],
            this.properties
        );
    }

    public reverse(): Jstream<T> {
        return new Jstream(
            () => {
                const source = this.getSource();

                if (!this.properties.freshSource && isArray(source)) {
                    return (function* () {
                        for (let i = source.length - 1; i >= 0; i--) {
                            yield source[i]!;
                        }
                    })();
                } else {
                    const array =
                        this.properties.freshSource && isArray(source)
                            ? source
                            : [...source];

                    array.reverse();
                    return array;
                }
            },
            { freshSource: true }
        );
    }

    public repeat(times: number | bigint): Jstream<T> {
        requireInteger(times);

        if (times === 0) return Jstream.empty();
        if (times < 0) return this.reverse().repeat(-times);

        const self = this;

        return new Jstream(function* () {
            const memoized = memoizeIterable(self);
            for (let i = 0n; i < times; i++) {
                for (const item of memoized) {
                    yield item;
                }
            }
        });
    }

    public defined(): Jstream<T & ({} | null)> {
        const self = this;
        return new Jstream(function* () {
            for (const item of self) {
                if (item !== undefined) yield item;
            }
        });
    }

    public nonNull(): Jstream<T & ({} | undefined)> {
        const self = this;
        return new Jstream(function* () {
            for (const item of self) {
                if (item !== null) yield item;
            }
        });
    }

    public copyWithin(
        target: number | bigint,
        start: number | bigint,
        end?: number | bigint
    ): Jstream<T> {
        return new Jstream(() =>
            this.toArray().copyWithin(
                Number(target),
                Number(start),
                Number(end)
            )
        );
    }

    public join<O, K, R>(
        other: Iterable<O>,
        keySelector: (item: T, index: number) => K,
        otherKeySelector: (item: O, index: number) => K,
        resultSelector: (item: T, otherItem: O) => R
    ): Jstream<R>;

    public join<O, K, R>(
        other: Iterable<O>,
        resultSelector: (item: T, otherItem: O) => R,
        comparison: (item: T, otherItem: O) => boolean
    ): Jstream<R>;

    public join<O, K, R>(
        other: Iterable<O>,
        keySelectorOrResultSelector:
            | ((item: T, index: number) => K)
            | ((item: T, otherItem: O) => R),
        otherKeySelectorOrComparison:
            | ((item: O, index: number) => K)
            | ((item: T, otherItem: O) => boolean),
        resultSelector?: (item: T, otherItem: O) => R
    ): Jstream<R> {
        const self = this;
        if (resultSelector !== undefined) {
            const keySelector = keySelectorOrResultSelector as (
                item: T,
                index: number
            ) => K;
            const otherKeySelector = otherKeySelectorOrComparison as (
                item: O,
                index: number
            ) => K;
            return new Jstream(function* () {
                const otherIndexed = toMap(other, otherKeySelector, identity);

                let i = 0;
                for (const item of self) {
                    const key = keySelector(item, i);
                    const otherItem = otherIndexed.get(key);
                    if (otherItem !== undefined) {
                        yield resultSelector(item, otherItem);
                    }
                    i++;
                }
            });
        } else {
            const resultSelector = keySelectorOrResultSelector as (
                item: T,
                otherItem: O
            ) => R;
            const comparison = otherKeySelectorOrComparison as (
                item: T,
                otherItem: O
            ) => boolean;

            return new Jstream(function* () {
                const otherCached = asStandardCollection(other) as Iterable<O>;

                let i = 0;
                for (const item of self) {
                    for (const otherItem of otherCached) {
                        if (comparison(item, otherItem)) {
                            yield resultSelector(item, otherItem);
                        }
                    }
                    i++;
                }
            });
        }
    }

    public leftJoin<I, K, R>(
        inner: Iterable<I>,
        keySelector: (item: T, index: number) => K,
        innerKeySelector: (item: I, index: number) => K,
        resultSelector: (item: T, innerItem: I | undefined) => R
    ): Jstream<R>;

    public leftJoin<I, K, R>(
        inner: Iterable<I>,
        resultSelector: (item: T, innerItem: I | undefined) => R,
        comparison: (item: T, innerItem: I) => boolean
    ): Jstream<R>;

    public leftJoin<I, K, R>(
        inner: Iterable<I>,
        keySelectorOrResultSelector:
            | ((item: T, index: number) => K)
            | ((item: T, innerItem: I | undefined) => R),
        innerKeySelectorOrComparison:
            | ((item: I, index: number) => K)
            | ((item: T, innerItem: I) => boolean),
        resultSelector?: (item: T, innerItem: I | undefined) => R
    ): Jstream<R> {
        const self = this;
        if (resultSelector !== undefined) {
            const keySelector = keySelectorOrResultSelector as (
                item: T,
                index: number
            ) => K;
            const innerKeySelector = innerKeySelectorOrComparison as (
                item: I,
                index: number
            ) => K;
            return new Jstream(function* () {
                const innerIndexed = toMap(inner, innerKeySelector, identity);

                let i = 0;
                for (const item of self) {
                    const key = keySelector(item, i);
                    const innerItem = innerIndexed.get(key);
                    yield resultSelector(item, innerItem);
                    i++;
                }
            });
        } else {
            const resultSelector = keySelectorOrResultSelector as (
                item: T,
                innerItem: I | undefined
            ) => R;
            const comparison = innerKeySelectorOrComparison as (
                item: T,
                innerItem: I
            ) => boolean;

            return new Jstream(function* () {
                const innerCached = asStandardCollection(inner) as Iterable<I>;

                for (const item of self) {
                    let innerMatch: I | undefined = undefined;
                    for (const innerItem of innerCached) {
                        if (comparison(item, innerItem)) {
                            innerMatch = innerItem;
                            break;
                        }
                    }
                    yield resultSelector(item, innerMatch);
                }
            });
        }
    }

    public groupJoin<I, K, R>(
        inner: Iterable<I>,
        keySelector: (item: T, index: number) => K,
        innerKeySelector: (item: I, index: number) => K,
        resultSelector: (item: T, innerItem: I[]) => R
    ): Jstream<R>;

    public groupJoin<I, K, R>(
        inner: Iterable<I>,
        resultSelector: (item: T, innerItem: I[]) => R,
        comparison: (item: T, innerItem: I) => boolean
    ): Jstream<R>;

    public groupJoin<I, K, R>(
        inner: Iterable<I>,
        keySelectorOrResultSelector:
            | ((item: T, index: number) => K)
            | ((item: T, innerItem: I[]) => R),
        innerKeySelectorOrComparison:
            | ((item: I, index: number) => K)
            | ((item: T, innerItem: I) => boolean),
        resultSelector?: (item: T, innerItem: I[]) => R
    ): Jstream<R> {
        const self = this;
        if (resultSelector !== undefined) {
            const keySelector = keySelectorOrResultSelector as (
                item: T,
                index: number
            ) => K;
            const innerKeySelector = innerKeySelectorOrComparison as (
                item: I,
                index: number
            ) => K;

            return new Jstream(function* () {
                const innerGrouped = groupBy(inner, innerKeySelector);

                let i = 0;
                for (const item of self) {
                    const key = keySelector(item, i);
                    const innerGroup = innerGrouped.get(key) ?? [];
                    yield resultSelector(item, innerGroup);
                    i++;
                }
            });
        } else {
            const resultSelector = keySelectorOrResultSelector as (
                item: T,
                innerItem: I[]
            ) => R;
            const comparison = innerKeySelectorOrComparison as (
                item: T,
                innerItem: I
            ) => boolean;

            return new Jstream(function* () {
                const innerCached = asStandardCollection(inner) as Iterable<I>;

                for (const item of self) {
                    let innerGroup: I[] = [];
                    for (const innerItem of innerCached) {
                        if (comparison(item, innerItem)) {
                            innerGroup.push(innerItem);
                        }
                    }
                    yield resultSelector(item, innerGroup);
                }
            });
        }
    }

    public reduce(
        reducer: (result: General<T>, item: T, index: number) => General<T>
    ): General<T>;

    public reduce<F>(
        reducer: (result: General<T>, item: T, index: number) => General<T>,
        finalize: (result: General<T>, count: number) => F
    ): F;

    public reduce<F = General<T>>(
        reducer: (result: General<T>, item: T, index: number) => General<T>,
        finalize?: (result: General<T>, count: number) => F
    ): F {
        const iterator = this[Symbol.iterator]();
        let next = iterator.next();

        if (next.done) {
            throw new Error("cannot reduce empty iterable. no initial value");
        }

        let i = 1;

        let result: General<T> = next.value as General<Awaited<T>>;

        while (!(next = iterator.next()).done) {
            result = reducer(result, next.value, i);

            i++;
        }

        if (finalize !== undefined) {
            return finalize(result, i);
        } else {
            return result as F;
        }
    }

    public fold<R>(
        initialValue: R,
        folder: (result: R, item: T, index: number) => R
    ): R;

    public fold<R, F>(
        initialValue: R,
        folder: (result: R, item: T, index: number) => R,
        finalize: (result: R, count: number) => F
    ): F;

    public fold<R, F = R>(
        initialValue: R,
        folder: (result: R, item: T, index: number) => R,
        finalize?: (result: R, count: number) => F
    ): F | R {
        let i = 1;
        let result = initialValue;

        for (const item of this) {
            result = folder(result, item, i);
            i++;
        }

        if (finalize !== undefined) {
            return finalize(result, i);
        } else {
            return result;
        }
    }

    public count(): number {
        const source = this.getSource();
        const nonIteratedCount = nonIteratedCountOrUndefined(source);

        if (nonIteratedCount !== undefined) {
            return nonIteratedCount;
        } else {
            let count = 0;
            for (const _ of source) count++;
            return count;
        }
    }

    public nonIteratedCountOrUndefined(): number | undefined {
        const source = this.getSource();
        return nonIteratedCountOrUndefined(source);
    }

    public toArray(): T[] {
        const source = this.getSource();
        if (this.properties.freshSource && Array.isArray(source)) {
            return source;
        } else {
            return [...source];
        }
    }

    public asArray(): readonly T[] {
        const source = this.getSource();
        if (Array.isArray(source)) {
            return source;
        } else {
            return [...source];
        }
    }

    public toSet(): Set<T> {
        const source = this.getSource();
        if (this.properties.freshSource && source instanceof Set) {
            return source;
        } else {
            return new Set(source);
        }
    }

    public asSet(): ReadonlySet<T> {
        const source = this.getSource();
        if (source instanceof Set) {
            return source;
        } else {
            return new Set(source);
        }
    }

    public toMap(): AsMap<Iterable<T>>;

    public toMap<V>(
        keySelector: undefined,
        valueSelector: (item: T, index: number) => V
    ): AsMapWithValue<Iterable<T>, V>;

    public toMap<K>(
        keySelector: (item: T, index: number) => K
    ): AsMapWithKey<Iterable<T>, K>;

    public toMap<K, V>(
        keySelector: (item: T, index: number) => K,
        valueSelector: (item: T, index: number) => V
    ): Map<K, V>;

    public toMap<
        K = T extends EntryLikeKey<infer K> ? K : unknown,
        V = T extends EntryLikeValue<infer V> ? V : unknown
    >(
        keySelector?: (item: T, index: number) => K,
        valueSelector?: (item: T, index: number) => V
    ): Map<K, V>;

    public toMap(
        keySelector?: (item: any, index: number) => any,
        valueSelector?: (item: any, index: number) => any
    ): Map<any, any> {
        return toMap(this, keySelector, valueSelector);
    }

    public asMap(): AsReadonly<AsMap<Iterable<T>>>;

    public asMap<V>(
        keySelector: undefined,
        valueSelector: (item: T, index: number) => V
    ): AsReadonly<AsMapWithValue<Iterable<T>, V>>;

    public asMap<K>(
        keySelector: (item: T, index: number) => K
    ): AsReadonly<AsMapWithKey<Iterable<T>, K>>;

    public asMap<K, V>(
        keySelector: (item: T, index: number) => K,
        valueSelector: (item: T, index: number) => V
    ): ReadonlyMap<K, V>;

    public asMap<
        K = T extends EntryLikeKey<infer K> ? K : unknown,
        V = T extends EntryLikeValue<infer V> ? V : unknown
    >(
        keySelector?: (item: T, index: number) => K,
        valueSelector?: (item: T, index: number) => V
    ): ReadonlyMap<K, V>;

    public asMap(
        keySelector?: (item: any, index: number) => any,
        valueSelector?: (item: any, index: number) => any
    ): ReadonlyMap<any, any> {
        const source = this.getSource();
        if (source instanceof Map) {
            return source;
        } else {
            return toMap(source, keySelector, valueSelector);
        }
    }

    public toObject(): ToObject<Iterable<T>>;

    public toObject<V>(
        keySelector: undefined,
        valueSelector: (item: T, index: number) => V
    ): ToObjectWithValue<Iterable<T>, V>;

    public toObject<K extends keyof any>(
        keySelector: (item: T, index: number) => K
    ): ToObjectWithKey<Iterable<T>, K>;

    public toObject<K extends keyof any, V>(
        keySelector: (item: T, index: number) => K,
        valueSelector: (item: T, index: number) => V
    ): Record<K, V>;

    public toObject(
        keySelector: (item: any, index: number) => keyof any = i => i?.[0],
        valueSelector: (item: any, index: number) => any = i => i?.[1]
    ): Record<keyof any, any> {
        const object: Record<keyof any, any> = {};

        let i = 0;
        for (const item of this) {
            const key = keySelector(item, i);
            const value = valueSelector(item, i);

            object[key] = value;

            i++;
        }

        return object;
    }

    public toStandardCollection(): StandardCollection<T> {
        const source = this.getSource();
        if (this.properties.freshSource && isStandardCollection(source)) {
            return source;
        } else {
            return [...source];
        }
    }

    public asStandardCollection(): ReadonlyStandardCollection<T> {
        const source = this.getSource();
        if (isStandardCollection(source)) {
            return source;
        } else {
            return [...source];
        }
    }

    public toAsyncJstream(): AsyncJstream<T> {
        return new AsyncJstream(this.getSource, this.properties);
    }

    public mkString(): string;
    public mkString(separator: any): string;
    public mkString(start: any, separator: any, end?: any): string;
    public mkString(
        startOrSeparator?: any,
        separator?: any,
        end?: any
    ): string {
        if (arguments.length === 1) {
            const separator = startOrSeparator;
            return mkString(this.getSource(), separator);
        } else {
            const start = startOrSeparator;
            return mkString(this.getSource(), start, separator, end);
        }
    }

    public toString(): string {
        return this.mkString();
    }

    public toJSON(): readonly T[] {
        return this.asArray();
    }
}

export class SortedJstream<T> extends Jstream<T> {
    private readonly order: readonly Order<T>[];
    private readonly comparison: Comparator<T>;
    private readonly getUnsortedSource: () => Iterable<T>;
    private readonly unsortedProperties: JstreamProperties<T>;

    public constructor(
        getSource: () => Iterable<T>,
        order: readonly Order<T>[],
        properties: JstreamProperties<T> = {}
    ) {
        super(
            () => {
                const source = getSource();
                let arr: T[];
                if (properties.freshSource && isArray(source)) {
                    arr = source;
                } else {
                    arr = [...source];
                }
                arr.sort(this.comparison);
                return arr;
            },
            { freshSource: true }
        );

        this.getUnsortedSource = getSource;
        this.unsortedProperties = properties;
        this.order = order;
        this.comparison = multiCompare(order);
    }

    public thenBy(order: Order<T>): SortedJstream<T> {
        return new SortedJstream<T>(
            this.getUnsortedSource,
            [...this.order, order],
            this.unsortedProperties
        );
    }

    public thenByDescending(order: Order<T>): SortedJstream<T> {
        return new SortedJstream<T>(
            this.getUnsortedSource,
            [...this.order, reverseOrder(order)],
            this.unsortedProperties
        );
    }
}
